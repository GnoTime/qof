<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 TRANSITIONAL//EN">
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=UTF-8">
<title>Why Qof?</title>
</head>
<body fgcolor="#000000" bgcolor="#ffffff">
<h1>Why QOF?</h1>
<a href="http://qof.sourceforge.net">
<img src="qof-logo.jpg" width="100" height="150" border="5" align=left>
</a>
<b><i>Summary:</b></i>
Desktop application development is not, and desktop application 
development for multi-user, client-server apps is so hard that 
almost no one attempts these.  In fact, this is the primary 
reason for the explosion of web applications:  If you need
to develop a multi-user, SQL-backed application, you can develop
it orders of magnitude more quickly by using Apache and PHP 
(or Java) than you can by using Gnome or KDE.  This is great
for the web, but terrible for anyone wanting to develop 
distributed, multi-user desktop applications.  There are many 
reasons why this is so, and there are many ways in which one
can attempt to change this situation.  One can boil the ocean
with this type of discussion; I won't attempt to do that here.
Instead, lets try to justify an approach like QOF in a broader
Free Software framework
<p>
A number of applications become much more interesting to thier
users when they have access to large quantities of data,
or are hooked into databases on the net in some way, or are
multi-usr or collaborative in some way.  In fact, any large-data
application is going to be multi-user, since having that much
data is valuable, and leads to a tremendous pressure to share.
There's a huge number of apps that fit this profile:
everything from shopping catalogues, where the store 'shares'
the product data with the customer, to Bugzilla, where the
bug status is 'shared' between developers and users, to 
p2p networks for sharing mp3's.
<p>
What does one need to build that kind of application?
Well, one needs at a minimum a query mechanism, so that the 
user can query, sort, report on and manipulate the data.  
Even good single-user apps need this ability: personal photo
and music organizers will have this kind of interface, as
well as address-books, and etc.

Next one needs .... ahhhh ..........


<p>
Note that much of this discussion is from the vantage point of Free
Software development, and explicitly ignores commercial/proprietary 
technologies.  It is also somewhat focused on 
<a href="http://qof.sourceforge.net">QOF</a> and the specific
case study of two applications that benefit from QOF: 
<a href="http://www.gnucash.org">GnuCash</a> and
<a href="http://gttr.sourceforge.net">GnoTime</a>. 

<p>
<h3>Application Architecture</h3>
QOF is an outgrowth of how I like to write application programs at
this stage in my life.  I'm not saying its the best way; in fact,
my development process seems very cumbersome to me, and I sometimes
wonder why I do it this way.  But I know the answer: I haven't heard
of a better way.  The "correct" way to design and architect a complex 
GUI application is highly debatable and rarely debated topic.
There is no dominant paradigm, no unifying philosophy.  Tools
and libraries are sorely lacking.  There are many promising avenues.
<p>
The starting point for the architecture is a modified
"Object/View/Controller" paradigm.  The GUI acts as a controller,
controlling and manipulating a set of objects in local system memory.
The objects in system memory are a cache, or mirror, or local copy
of data in a (remote) database.   Two technical problems immediately
present themselves.  One is how to connect the GUI to the objects in 
an easy-to-develop, easy-to-maintain style.  The second is how to 
do the same in keeping the local copy of the objects in sync with 
the database.  In particular, how keep them in sync with the data 
in other (remote) objects that other users might be manipulating.
One possible answer, and that is the answer used today by GnuCash,
is to design the GUI with the <a href="http://glade.gnome.org">Glade</a>
graphical GUI designer, and hook it up to some C (could have been 
C++, or even other language) objects.  The objects are in turn loaded
from either a file, or fetched from an SQL database.
<p>
I (would) like to have my apps be natively multi-user.  This means dealing
with all of the locking and caching problems that multi-user presents.
Multi-user also means that one needs to have a centralized data storage
location: a database, and by presumption, an SQL database.   Thus, if
one wants to have C objects, one needs to shim them onto SQL somehow.
Today, for me, this is a labour-intensive, manual process.  In the
commercial software world, there are tools and companies that have
systems that make this a lot easier, and even automatic; but there
aren't any in the Free Software world.
<p>
After writing the shims between the first half-dozen objects and thier
equivalent SQL tables, it becomes painfully appearent that the process
can be mostly automated, as the shims consists of mostly common code.
Unfortunately, the automatition of this process is easier said than
done.  At first, it seems that all one needs is to specify a mapping 
or 'dictionary' from an SQL table field to an object setter/getter.
In practice, its more subtle than that.   None-the-less, one of the
goals of QOF is to provide a fairly generic dictionary or mapping
mechanism.  To the best of my knowledge, as of today, in the 
Free Software/Open Source world, there is only one system that maps
databases to objects, and back: 
<a href="http://dwi.sourceforge.net">DWI/DUI</a>.  However, that
system is still rather primitive.  At least one goal is to have 
QOF integrate with and expanmd on that function.


<p>
<h3>Core Assumptions</h3>
The QOF project, and the above comments, make some core assumptions
that are questionable, and need to be addressed. These are discussed 
below.
<p>
<ul>
<li> <p><b>Why C (or C++)? Why not a better language?</b>
     The C/C++ language has many ther problems, the most serious of which 
     is the lack of garbage collection and of any sort of persistance.
     In particular, C/C++ lack "object introspection", the ability to 
     have a subroutine, when given an object of unknown type, to find
     out about the object that it's dealing with.
     Why not in another language, one that can do introspection, and has
     object factories in it? e.g. Java, python, C#?  The short answer:
     because the mapping between the dynamic (cached) object, and the 
     thing that needs to be persisitent, is not one-to-one.  Thus, 
     introspection is not enough: one really does need to specify how to 
     map object fields to database fields; the mapping is not natively 
     or inherently 1-to-1.  Thus, the object introspection available in
     these othe languages doesn't solve all problems.  One still needs
     to explicitly specify the mapping, while still making it easy on the
     programmer.
     </p>
     <br>
<li> <p>Why not go directly from GUI to SQL, and back?  This is the traditional
     'data-driven' programming style.  It has short-comings, the most notable
     of which is the inability (or difficulty of) implenmenting application
     behaviour.  One can all too easily get sucked into writing SQL triggers
     and stored proceedures. That's bad.
     Note, however, that much of what a typical GUI application does can,
     in fact, be specified by a declarative language; an algorithmic,
     proceedural language, such as C, really is not required for the 
     vast majority of the application guts.
     </p>
     <br>
<li><p>Why not use GLib GObjects?  I dunno.
    </p>
<li><p>Why not UML?  What's UML got to do with it?
    </p>
     <br>
</ul>

... Unfinished ... Draft ... 


<hr>
Linas Vepstas &lt;linas@linas.org&gt; July 2003, April 2004



</body>
</html>
